<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corporate Ladder</title>
    <link rel="icon" type="image/png" href="/icons/lightbulb-noto.png" />
    <link rel="apple-touch-icon" href="/icons/lightbulb-noto.png" />
    <meta name="theme-color" content="#3f3f46" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Noto+Color+Emoji&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        /* Basic Setup */
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }
        body {
            background-color: #f4f4f5; /* Warmer light gray */
            color: #3f3f46; /* Warmer dark text */
            font-family: 'Roboto', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .game-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* Game Viewport */
        .viewport {
            position: relative;
            background-color: #000;
            overflow: hidden;
            flex-grow: 1;
            flex-shrink: 1;
            flex-basis: 0;
        }

        .map-container {
            position: absolute;
            top: 0; left: 0;
        }
        
        /* FOG OF WAR */
        .fog-container {
            position: absolute;
            top: 0; left: 0;
            pointer-events: none;
            z-index: 100;
        }
        .fog-tile {
            --tile-size: 32px;
            width: var(--tile-size);
            height: var(--tile-size);
            position: absolute;
            background-color: #202124; /* Softer off-black */
            transition: opacity 0.3s;
        }
        .fog-tile.visible { opacity: 0; }
        .fog-tile.revealed { opacity: 0.6; }


        /* Tiles and Entities */
        .tile, .entity {
            --tile-size: 32px;
            width: var(--tile-size);
            position: absolute;
            box-sizing: border-box;
        }
        .tile {
            height: var(--tile-size);
        }
        .floor { background-color: #b8c0ca; } 
        
        .wall, .entity {
            height: calc(var(--tile-size) * 1.5);
        }
        .wall { background-color: #f5f5f5; } 
        .wall.front-face {
            border-bottom: 8px solid #b0b0b0;
        }

        .entity {
            font-size: calc(var(--tile-size) * 0.8);
            font-family: 'Noto Color Emoji', sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: calc(var(--tile-size) * 0.2);
            transition: top 0.1s linear, left 0.1s linear;
        }

        /* UI Panel */
        .ui-panel {
            width: 300px;
            flex-shrink: 0;
            background: #ffffff;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 12px; /* Reduced gap */
            box-shadow: -2px 0 5px rgba(0,0,0,0.08);
            border-left: 1px solid #e4e4e7;
        }
        .ui-panel h3 { margin: 0 0 8px 0; padding-bottom: 8px; border-bottom: 1px solid #e4e4e7; flex-shrink: 0; font-size: 1em; font-weight: 500; color: #3c4043; }
        
        .stats-section, .inventory-section, .skills-section { flex-shrink: 0; }
        .log-section { flex-grow: 1; min-height: 0; display: flex; flex-direction: column; }
        .log-container { flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; }
        
        .log-container p { font-size: 0.85em; margin: 0 0 4px 0; color: #70757a;}

        /* INVENTORY GRID */
        #inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(44px, 1fr));
            gap: 6px;
            min-height: 50px;
        }
        .inventory-slot {
            width: 44px;
            height: 44px;
            background: #f1f3f4;
            border: 1px solid #dadce0;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 22px;
            font-family: 'Noto Color Emoji', sans-serif;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s;
        }
        .inventory-slot:hover { background-color: #dee1e3; }
        .item-count {
            position: absolute;
            bottom: 1px;
            right: 3px;
            font-size: 11px;
            font-weight: 500;
            color: #3c4043;
            background: rgba(255,255,255,0.7);
            border-radius: 4px;
            padding: 0 3px;
        }
        .tooltip {
            visibility: hidden;
            width: max-content;
            background-color: #3c4043;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 1001;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 0.8em;
        }
        .inventory-slot:hover .tooltip, .stat:hover .tooltip, .skill:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        /* STAT BARS & SKILLS */
        .stat, .skill { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; position: relative; }
        .stat .material-icons, .skill .material-icons { font-size: 20px; color: #5f6368; cursor: default; }
        .stat-bar-container { flex-grow: 1; background-color: #e8eaed; border-radius: 99px; overflow: hidden; height: 8px; box-shadow: inset 0 1px 1px rgba(0,0,0,0.1); }
        .stat-bar { height: 100%; transition: width 0.3s ease-out; }
        .skills-grid { display: flex; gap: 16px; }
        .skill-value { font-weight: 500; font-size: 0.9em; color: #3c4043; }

        #productivity-bar { background: linear-gradient(to right, #4185f4, #63a0ff); }
        #happiness-bar { background: linear-gradient(to right, #34a853, #57c787); }
        #reputation-bar { background: linear-gradient(to right, #fbbc05, #fcd35a); }

        /* Game Over Overlay */
        #game-over-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.8); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; text-align: center; padding: 20px;}
        #game-over-overlay.visible { display: flex; }
        #game-over-overlay h2 { font-size: 36px; color: #d93025; }
        #game-over-overlay p { font-size: 18px; color: #e8eaed; }
        #restart-button { margin-top: 20px; padding: 15px 30px; font-size: 20px; cursor: pointer; background: #34a853; color: white; border: none; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: background-color 0.2s; }
        #restart-button:hover { background-color: #44b964; }

    </style>
</head>
<body>

    <div class="game-container" id="game-container">
        <div class="viewport" id="viewport">
            <div class="map-container" id="map-container"></div>
            <div class="fog-container" id="fog-container"></div>
            <div id="game-over-overlay">
                <h2 id="game-over-title"></h2>
                <p id="game-over-text"></p>
                <button id="restart-button">Start a New Career</button>
            </div>
        </div>
        <div class="ui-panel">
            <div class="stats-section">
                <h3>FLOOR <span id="floor-number">1</span></h3>
                <div class="stat">
                    <i class="material-icons">trending_up</i>
                    <div class="stat-bar-container"><div id="productivity-bar" class="stat-bar"></div></div>
                    <span class="tooltip">Productivity</span>
                </div>
                <div class="stat">
                    <i class="material-icons">sentiment_satisfied</i>
                    <div class="stat-bar-container"><div id="happiness-bar" class="stat-bar"></div></div>
                     <span class="tooltip">Happiness</span>
                </div>
                <div class="stat">
                    <i class="material-icons">groups</i>
                    <div class="stat-bar-container"><div id="reputation-bar" class="stat-bar"></div></div>
                     <span class="tooltip">Reputation</span>
                </div>
            </div>
            <div class="skills-section">
                <h3>SKILLS</h3>
                <div class="skills-grid">
                    <div class="skill">
                        <i class="material-icons">model_training</i>
                        <span class="skill-value" id="proficiency-skill">0</span>
                        <span class="tooltip">Proficiency</span>
                    </div>
                     <div class="skill">
                        <i class="material-icons">psychology</i>
                        <span class="skill-value" id="teamwork-skill">0</span>
                        <span class="tooltip">Teamwork</span>
                    </div>
                </div>
            </div>
            <div class="inventory-section">
                <h3>INVENTORY</h3>
                <div id="inventory-grid"></div>
            </div>
            <div class="log-section">
                <h3>MEMOS</h3>
                <div class="log-container" id="log-container">
                    <div id="log-messages"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM ELEMENTS ---
            const gameContainer = document.getElementById('game-container');
            const viewport = document.getElementById('viewport');
            const mapContainer = document.getElementById('map-container');
            const fogContainer = document.getElementById('fog-container');
            const productivityBar = document.getElementById('productivity-bar');
            const happinessBar = document.getElementById('happiness-bar');
            const reputationBar = document.getElementById('reputation-bar');
            const floorNumber = document.getElementById('floor-number');
            const proficiencySkill = document.getElementById('proficiency-skill');
            const teamworkSkill = document.getElementById('teamwork-skill');
            const inventoryGrid = document.getElementById('inventory-grid');
            const logContainer = document.getElementById('log-container');
            const logMessages = document.getElementById('log-messages');
            const gameOverOverlay = document.getElementById('game-over-overlay');
            const gameOverTitle = document.getElementById('game-over-title');
            const gameOverText = document.getElementById('game-over-text');
            const restartButton = document.getElementById('restart-button');

            // --- CONSTANTS ---
            const TILE_SIZE = 32;
            const MAP_WIDTH = 50, MAP_HEIGHT = 50;
            const MIN_ROOMS = 5, MAX_ROOMS = 10;
            const MIN_ROOM_SIZE = 6, MAX_ROOM_SIZE = 12;
            const FOV_RADIUS = 8;
            const CEO_FLOOR = 3; 

            // --- GAME STATE ---
            let state = {};

            // --- UTILITY ---
            const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
            const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // --- RENDER FUNCTIONS ---
            function renderAll() {
                renderMapAndEntities();
                renderFogOfWar();
                renderUI();
            }

            let renderScheduled = false;
            function scheduleRender() {
                if (renderScheduled) return;
                renderScheduled = true;
                requestAnimationFrame(() => {
                    renderScheduled = false;
                    renderAll();
                });
            }

            function renderMapAndEntities() {
                if (!state.player) return;
                mapContainer.innerHTML = '';

                const viewportWidth = viewport.clientWidth;
                const viewportHeight = viewport.clientHeight;
                const tilesX = Math.ceil(viewportWidth / TILE_SIZE);
                const tilesY = Math.ceil(viewportHeight / TILE_SIZE);
                const startCol = state.player.pos.x - Math.floor(tilesX / 2);
                const startRow = state.player.pos.y - Math.floor(tilesY / 2);

                mapContainer.style.width = `${tilesX * TILE_SIZE}px`;
                mapContainer.style.height = `${tilesY * TILE_SIZE}px`;

                const tilesFragment = document.createDocumentFragment();
                for (let y = 0; y < tilesY; y++) {
                    for (let x = 0; x < tilesX; x++) {
                        const mapX = startCol + x;
                        const mapY = startRow + y;

                        if (mapX < 0 || mapX >= MAP_WIDTH || mapY < 0 || mapY >= MAP_HEIGHT) continue;
                        
                        const tile = state.map[mapY][mapX];
                        if (!tile.revealed) continue;

                        const tileDiv = document.createElement('div');
                        const isWall = tile.isWall;
                        
                        tileDiv.className = `tile ${isWall ? 'wall' : 'floor'}`;
                        tileDiv.style.left = `${x * TILE_SIZE}px`;
                        
                        const yOffset = isWall ? TILE_SIZE * 0.5 : 0;
                        tileDiv.style.top = `${y * TILE_SIZE - yOffset}px`;
                        tileDiv.style.zIndex = y;
                        
                        const isFrontWall = isWall && (mapY + 1 >= MAP_HEIGHT || !state.map[mapY + 1][mapX].isWall);
                        if(isFrontWall) tileDiv.classList.add('front-face');

                        tilesFragment.appendChild(tileDiv);
                    }
                }
                mapContainer.appendChild(tilesFragment);

                const entitiesToRender = [...state.items, ...state.coworkers, ...state.computers, ...state.dogs, state.player, state.elevator];
                const entitiesFragment = document.createDocumentFragment();
                entitiesToRender.forEach(entity => {
                    if (!entity) return;
                    const entityX = entity.pos.x - startCol;
                    const entityY = entity.pos.y - startRow;
                    if (entityX < 0 || entityX >= tilesX || entityY < 0 || entityY >= tilesY) return;
                    const entityDiv = document.createElement('div');
                    entityDiv.className = 'entity';
                    entityDiv.id = entity.id;
                    entityDiv.textContent = entity.emoji;
                    entityDiv.style.left = `${entityX * TILE_SIZE}px`;
                    const yOffset = TILE_SIZE * 0.5;
                    entityDiv.style.top = `${entityY * TILE_SIZE - yOffset}px`;
                    entityDiv.style.zIndex = entityY;
                    entitiesFragment.appendChild(entityDiv);
                });
                mapContainer.appendChild(entitiesFragment);
            }

            function renderFogOfWar() {
                if (!state.player) return;
                fogContainer.innerHTML = '';
                const viewportWidth = viewport.clientWidth;
                const viewportHeight = viewport.clientHeight;
                const tilesX = Math.ceil(viewportWidth / TILE_SIZE);
                const tilesY = Math.ceil(viewportHeight / TILE_SIZE);
                const startCol = state.player.pos.x - Math.floor(tilesX / 2);
                const startRow = state.player.pos.y - Math.floor(tilesY / 2);

                fogContainer.style.width = `${tilesX * TILE_SIZE}px`;
                fogContainer.style.height = `${tilesY * TILE_SIZE}px`;

                const fogFragment = document.createDocumentFragment();
                for (let y = 0; y < tilesY; y++) {
                    for (let x = 0; x < tilesX; x++) {
                        const mapX = startCol + x;
                        const mapY = startRow + y;
                        
                        let tileState = 'hidden';
                        
                        if (mapX >= 0 && mapX < MAP_WIDTH && mapY >= 0 && mapY < MAP_HEIGHT) {
                            const tile = state.map[mapY][mapX];
                            if (tile.visible) {
                                tileState = 'visible';
                            } else if (tile.revealed) {
                                tileState = 'revealed';
                            }
                        }

                        if (tileState !== 'visible') {
                            const fogDiv = document.createElement('div');
                            fogDiv.className = `fog-tile ${tileState}`;
                            fogDiv.style.left = `${x * TILE_SIZE}px`;
                            fogDiv.style.top = `${y * TILE_SIZE}px`;
                            fogFragment.appendChild(fogDiv);
                        }
                    }
                }
                fogContainer.appendChild(fogFragment);
            }


            function renderUI() {
                if (!state.player) return;
                const p = state.player;
                productivityBar.style.width = `${(p.productivity / p.maxProductivity) * 100}%`;
                happinessBar.style.width = `${p.happiness}%`;
                reputationBar.style.width = `${p.reputation}%`;
                floorNumber.textContent = state.floor;
                proficiencySkill.textContent = p.skills.proficiency;
                teamworkSkill.textContent = p.skills.teamwork;
                
                inventoryGrid.innerHTML = '';
                const inventoryItems = Object.keys(p.inventory);

                if (inventoryItems.length === 0) {
                    inventoryGrid.innerHTML = '<p class="empty">Empty</p>';
                } else {
                    inventoryItems.forEach(itemName => {
                        const item = state.itemTypes.find(it => it.name === itemName);
                        const count = p.inventory[itemName];
                        if (!item || count <= 0) return;

                        const slotDiv = document.createElement('div');
                        slotDiv.className = 'inventory-slot';
                        slotDiv.dataset.itemName = itemName;
                        slotDiv.innerHTML = `
                            ${item.emoji}
                            <span class="tooltip">${item.name.replace('a ', '')}</span>
                            ${count > 1 ? `<span class="item-count">${count}</span>` : ''}
                        `;
                        inventoryGrid.appendChild(slotDiv);
                    });
                }
                
                logMessages.innerHTML = state.messages.map(msg => `<p>${msg}</p>`).join('');
                logContainer.scrollTop = logContainer.scrollHeight;
            }
            
            // --- GAME LOGIC ---
            function calculateFov() {
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        state.map[y][x].visible = false;
                    }
                }
                
                const octantTransforms = [
                    { xx: 1, xy: 0, yx: 0, yy: 1 }, { xx: 0, xy: 1, yx: 1, yy: 0 },
                    { xx: 0, xy: -1, yx: 1, yy: 0 }, { xx: -1, xy: 0, yx: 0, yy: 1 },
                    { xx: -1, xy: 0, yx: 0, yy: -1 }, { xx: 0, xy: -1, yx: -1, yy: 0 },
                    { xx: 0, xy: 1, yx: -1, yy: 0 }, { xx: 1, xy: 0, yx: 0, yy: -1 }
                ];

                function castShadows(cx, cy, row, start, end, transform) {
                    if (start < end) return;
                    let newStart = 0.0;
                    for (let j = row; j <= FOV_RADIUS; j++) {
                        let blocked = false;
                        for (let dx = -j; dx <= 0; dx++) {
                            let dy = -j;
                            let l_slope = (dx - 0.5) / (dy + 0.5);
                            let r_slope = (dx + 0.5) / (dy - 0.5);

                            if (start < r_slope) continue;
                            if (end > l_slope) break;

                            let sax = dx * transform.xx + dy * transform.xy;
                            let say = dx * transform.yx + dy * transform.yy;
                            let mapX = cx + sax;
                            let mapY = cy + say;
                            
                            if (mapX < 0 || mapX >= MAP_WIDTH || mapY < 0 || mapY >= MAP_HEIGHT) continue;

                            state.map[mapY][mapX].visible = true;
                            state.map[mapY][mapX].revealed = true;

                            if (blocked) {
                                if (state.map[mapY][mapX].isWall) {
                                    newStart = r_slope;
                                    continue;
                                } else {
                                    blocked = false;
                                    start = newStart;
                                }
                            } else if (state.map[mapY][mapX].isWall) {
                                blocked = true;
                                castShadows(cx, cy, j + 1, start, l_slope, transform);
                                newStart = r_slope;
                            }
                        }
                        if (blocked) break;
                    }
                }
                
                state.map[state.player.pos.y][state.player.pos.x].visible = true;
                state.map[state.player.pos.y][state.player.pos.x].revealed = true;

                for (let i = 0; i < 8; i++) {
                    castShadows(state.player.pos.x, state.player.pos.y, 1, 1.0, 0.0, octantTransforms[i]);
                }
                
                const playerRoom = state.rooms.find(r => 
                    state.player.pos.x >= r.x && state.player.pos.x < r.x + r.width &&
                    state.player.pos.y >= r.y && state.player.pos.y < r.y + r.height
                );
                if (playerRoom) {
                    for (let y = playerRoom.y; y < playerRoom.y + playerRoom.height; y++) {
                        for (let x = playerRoom.x; x < playerRoom.x + playerRoom.width; x++) {
                            state.map[y][x].visible = true;
                            state.map[y][x].revealed = true;
                        }
                    }
                }
                
                // Penumbra effect removed for performance
            }


            function addMessage(msg) {
                state.messages.push(msg);
                state.messages = state.messages.slice(-20);
            }

            function handleNpcTurns() {
                 state.coworkers.forEach(coworker => {
                    if (!state.map[coworker.pos.y][coworker.pos.x].visible) return;

                    let dx = 0, dy = 0;

                    if (coworker.behavior === 'chase') {
                        dx = Math.sign(state.player.pos.x - coworker.pos.x);
                        dy = Math.sign(state.player.pos.y - coworker.pos.y);
                    } else if (coworker.behavior === 'flee') {
                        dx = -Math.sign(state.player.pos.x - coworker.pos.x);
                        dy = -Math.sign(state.player.pos.y - coworker.pos.y);
                    }

                    if (dx === 0 && dy === 0) return;

                    const nextPos = { x: coworker.pos.x + dx, y: coworker.pos.y + dy };
                    const isPlayerPos = nextPos.x === state.player.pos.x && nextPos.y === state.player.pos.y;
                    const isOccupied = state.coworkers.some(c => c.pos.x === nextPos.x && c.pos.y === nextPos.y);

                    if (isPlayerPos && coworker.behavior === 'chase') {
                        addMessage(`${coworker.name} caught you!`);
                        const teamworkBonus = 1 + (state.player.skills.teamwork * 0.05);
                        state.player.productivity = clamp(state.player.productivity + (coworker.effects.productivity / teamworkBonus), 0, state.player.maxProductivity);
                        state.player.happiness = clamp(state.player.happiness + (coworker.effects.happiness * teamworkBonus), 0, 100);
                        state.player.reputation = clamp(state.player.reputation + (coworker.effects.reputation * teamworkBonus), 0, 100);
                    } else if (state.map[nextPos.y]?.[nextPos.x]?.walkable && !isOccupied && !isPlayerPos) {
                        coworker.pos = nextPos;
                    }
                });
                state.dogs.forEach(dog => {
                    const dx = getRandomInt(-1, 1);
                    const dy = getRandomInt(-1, 1);
                    const nextPos = { x: dog.pos.x + dx, y: dog.pos.y + dy };
                    const isPlayerPos = nextPos.x === state.player.pos.x && nextPos.y === state.player.pos.y;
                    const isOccupied = state.dogs.some(d => d.id !== dog.id && d.pos.x === nextPos.x && d.pos.y === nextPos.y);
                    if (state.map[nextPos.y]?.[nextPos.x]?.walkable && !isOccupied && !isPlayerPos) {
                        dog.pos = nextPos;
                    }
                });
            }

            function takePlayerTurn(action, data) {
                if (state.gameOver) return;
                
                let turnTaken = false;
                if (action === 'move') {
                    const { dx, dy } = data;
                    const targetPos = { x: state.player.pos.x + dx, y: state.player.pos.y + dy };
                    if (targetPos.y < 0 || targetPos.y >= MAP_HEIGHT || targetPos.x < 0 || targetPos.x >= MAP_WIDTH) return;

                    if (targetPos.x === state.elevator.pos.x && targetPos.y === state.elevator.pos.y) {
                        state.floor++;
                        if (state.floor > CEO_FLOOR) {
                            handleCeoEncounter();
                        } else {
                            addMessage(`You take the elevator to floor ${state.floor}.`);
                            generateLevel();
                        }
                        turnTaken = true;
                    } else {
                        const coworkerIndex = state.coworkers.findIndex(c => c.pos.x === targetPos.x && c.pos.y === targetPos.y);
                        const computerIndex = state.computers.findIndex(c => c.pos.x === targetPos.x && c.pos.y === targetPos.y);
                        const dogIndex = state.dogs.findIndex(d => d.pos.x === targetPos.x && d.pos.y === targetPos.y);

                        if (coworkerIndex !== -1) {
                            const coworker = state.coworkers[coworkerIndex];
                             if (coworker.behavior === 'flee') {
                                addMessage(`You cornered ${coworker.name}! They give you some tips.`);
                                state.player.productivity = clamp(state.player.productivity + coworker.effects.productivity, 0, state.player.maxProductivity);
                                state.coworkers.splice(coworkerIndex, 1);
                            } else {
                                addMessage(`You chat with ${coworker.name}.`);
                                const teamworkBonus = 1 + (state.player.skills.teamwork * 0.05);
                                state.player.productivity = clamp(state.player.productivity + (coworker.effects.productivity / teamworkBonus), 0, state.player.maxProductivity);
                                state.player.happiness = clamp(state.player.happiness + (coworker.effects.happiness * teamworkBonus), 0, 100);
                                state.player.reputation = clamp(state.player.reputation + (coworker.effects.reputation * teamworkBonus), 0, 100);
                                state.player.skills.teamwork++;
                            }
                            turnTaken = true;
                        } else if (computerIndex !== -1) {
                            const productivityGain = 15 + state.player.skills.proficiency;
                            addMessage(`You answer some emails. (+${productivityGain} Prod)`);
                            state.player.productivity = clamp(state.player.productivity + productivityGain, 0, state.player.maxProductivity);
                            state.player.happiness = clamp(state.player.happiness - 5, 0, 100);
                            state.player.skills.proficiency++;
                            turnTaken = true;
                        } else if (dogIndex !== -1) {
                            const dog = state.dogs[dogIndex];
                            addMessage(`You pet ${dog.name}. Your spirits are lifted!`);
                            state.player.happiness = clamp(state.player.happiness + 20, 0, 100);
                            turnTaken = true;
                        } else if (state.map[targetPos.y][targetPos.x].walkable) {
                            state.player.pos = targetPos;
                            const itemIndex = state.items.findIndex(i => i.pos.x === targetPos.x && i.pos.y === targetPos.y);
                            if (itemIndex !== -1) {
                                const item = state.items[itemIndex];
                                state.player.inventory[item.name] = (state.player.inventory[item.name] || 0) + 1;
                                addMessage(`You picked up ${item.name}.`);
                                state.items.splice(itemIndex, 1);
                            }
                            turnTaken = true;
                        }
                    }
                } else if (action === 'use_item') {
                    const itemName = data.name;
                    const item = state.itemTypes.find(it => it.name === itemName);
                    if (item && state.player.inventory[itemName] > 0) {
                        addMessage(`You use ${item.name}.`);
                        state.player.productivity = clamp(state.player.productivity + item.effects.productivity, 0, state.player.maxProductivity);
                        state.player.happiness = clamp(state.player.happiness + item.effects.happiness, 0, 100);
                        state.player.reputation = clamp(state.player.reputation + item.effects.reputation, 0, 100);
                        state.player.inventory[itemName]--;
                        if (state.player.inventory[itemName] <= 0) {
                            delete state.player.inventory[itemName];
                        }
                        turnTaken = true;
                    }
                }

                if (turnTaken) {
                    state.player.productivity = clamp(state.player.productivity - 1, 0, state.player.maxProductivity);
                    if (state.player.productivity < 40 && Math.random() < 0.1) {
                        addMessage("Your manager sends a 'gentle reminder' about deadlines.");
                    }
                    handleNpcTurns();
                    calculateFov();
                    scheduleRender();
                    checkGameOver();
                }
            }

            function checkGameOver() {
                if (state.player.productivity <= 0) {
                    state.gameOver = true;
                    gameOverTitle.textContent = "You're Fired!";
                    gameOverText.textContent = "Your productivity dropped to zero. Management has decided to 're-evaluate your position'.";
                    gameOverOverlay.classList.add('visible');
                } else if (state.player.happiness <= 0) {
                    state.gameOver = true;
                    gameOverTitle.textContent = "You Quit!";
                    gameOverText.textContent = "You're completely burnt out. You storm out of the office in search of a new, less soul-crushing life.";
                    gameOverOverlay.classList.add('visible');
                } else if (state.player.reputation <= 0) {
                    state.gameOver = true;
                    gameOverTitle.textContent = "You're Fired!";
                    gameOverText.textContent = "Your reputation is in shambles. You've been 'let go' to 'pursue other opportunities'.";
                    gameOverOverlay.classList.add('visible');
                }
            }
            
            function handleCeoEncounter() {
                state.gameOver = true;
                const score = (state.player.productivity / state.player.maxProductivity * 100) + state.player.happiness + state.player.reputation;
                if (score > 250) {
                    gameOverTitle.textContent = "Promotion!";
                    gameOverText.textContent = "The CEO is impressed with your synergy! You're promoted to Senior Vice President of Something-or-Other.";
                } else if (score > 150) {
                    gameOverTitle.textContent = "A Pat on the Back";
                    gameOverText.textContent = "The CEO nods. 'Good work. Keep it up.' You get a branded water bottle for your efforts.";
                } else {
                    gameOverTitle.textContent = "Downsized!";
                    gameOverText.textContent = "The CEO looks at your performance review. 'We're looking for more... alignment.' You've been synergistically downsized.";
                }
                gameOverOverlay.classList.add('visible');
            }

            function handleLayout() {
                const aspectRatio = window.innerWidth / window.innerHeight;
                if (aspectRatio > 1.2) { // Landscape
                    gameContainer.style.flexDirection = 'row';
                    document.querySelector('.ui-panel').style.height = '100%';
                    document.querySelector('.ui-panel').style.width = '300px';

                } else { // Portrait
                    gameContainer.style.flexDirection = 'column';
                    document.querySelector('.ui-panel').style.height = '40%';
                    document.querySelector('.ui-panel').style.width = '100%';
                }
                scheduleRender();
            }

            function generateLevel() {
                const map = Array.from({ length: MAP_HEIGHT }, () => Array.from({ length: MAP_WIDTH }, () => ({ walkable: false, visible: false, revealed: false, isWall: true })));
                const rooms = [];
                const coworkers = [];
                const items = [];
                const computers = [];
                const dogs = [];
                const numRooms = getRandomInt(MIN_ROOMS, MAX_ROOMS);
                const dogEmojis = ['🐕', '🐩', '🦮', '🐕‍🦺'];

                for (let i = 0; i < numRooms; i++) {
                    let room, overlaps, attempt = 0;
                    do {
                        room = { width: getRandomInt(MIN_ROOM_SIZE, MAX_ROOM_SIZE), height: getRandomInt(MIN_ROOM_SIZE, MAX_ROOM_SIZE), x: getRandomInt(1, MAP_WIDTH - 1 - MAX_ROOM_SIZE), y: getRandomInt(1, MAP_HEIGHT - 1 - MAX_ROOM_SIZE) };
                        overlaps = rooms.some(r => room.x < r.x + r.width + 1 && room.x + r.width + 1 > r.x && room.y < r.y + r.height + 1 && room.y + r.height + 1 > r.y);
                        attempt++;
                    } while (overlaps && attempt < 1000);

                    if (!overlaps) {
                        for (let y = room.y; y < room.y + room.height; y++) for (let x = room.x; x < room.x + room.width; x++) { map[y][x].walkable = true; map[y][x].isWall = false; }

                        if (i > 0) {
                            if (Math.random() > 0.5) {
                                const pos = { x: getRandomInt(room.x, room.x + room.width - 1), y: getRandomInt(room.y, room.y + room.height - 1) };
                                const type = state.coworkerTypes[getRandomInt(0, state.coworkerTypes.length - 1)];
                                coworkers.push({ id: `coworker-${i}`, pos, ...type });
                            }
                            if (Math.random() > 0.3) {
                                const pos = { x: getRandomInt(room.x, room.x + room.width - 1), y: getRandomInt(room.y, room.y + room.height - 1) };
                                const type = state.itemTypes[getRandomInt(0, state.itemTypes.length - 1)];
                                items.push({ id: `item-${i}`, pos, ...type });
                            }
                             if (Math.random() > 0.7) {
                                const pos = { x: getRandomInt(room.x, room.x + room.width - 1), y: getRandomInt(room.y, room.y + room.height - 1) };
                                computers.push({ id: `computer-${i}`, pos, emoji: '🖥️' });
                                map[pos.y][pos.x].walkable = false;
                            }
                             if (Math.random() > 0.8) {
                                const pos = { x: getRandomInt(room.x, room.x + room.width - 1), y: getRandomInt(room.y, room.y + room.height - 1) };
                                dogs.push({ id: `dog-${i}`, pos, name: "your coworker's dog", emoji: dogEmojis[getRandomInt(0, dogEmojis.length - 1)] });
                            }
                        }
                        if (rooms.length > 0) {
                            const prevCenter = { x: Math.floor(rooms[rooms.length - 1].x + rooms[rooms.length - 1].width / 2), y: Math.floor(rooms[rooms.length - 1].y + rooms[rooms.length - 1].height / 2) };
                            const newCenter = { x: Math.floor(room.x + room.width / 2), y: Math.floor(room.y + room.height / 2) };
                            if (Math.random() > 0.5) {
                                for (let x = Math.min(prevCenter.x, newCenter.x); x <= Math.max(prevCenter.x, newCenter.x); x++) { map[prevCenter.y][x].walkable = true; map[prevCenter.y][x].isWall = false; }
                                for (let y = Math.min(prevCenter.y, newCenter.y); y <= Math.max(prevCenter.y, newCenter.y); y++) { map[y][newCenter.x].walkable = true; map[y][newCenter.x].isWall = false; }
                            } else {
                                for (let y = Math.min(prevCenter.y, newCenter.y); y <= Math.max(prevCenter.y, newCenter.y); y++) { map[y][prevCenter.x].walkable = true; map[y][prevCenter.x].isWall = false; }
                                for (let x = Math.min(prevCenter.x, newCenter.x); x <= Math.max(prevCenter.x, newCenter.x); x++) { map[newCenter.y][x].walkable = true; map[newCenter.y][x].isWall = false; }
                            }
                        }
                        rooms.push(room);
                    }
                }
                const playerStartRoom = rooms[0];
                state.player.pos = { x: Math.floor(playerStartRoom.x + playerStartRoom.width / 2), y: Math.floor(playerStartRoom.y + playerStartRoom.height / 2) };
                
                // Add "desk" to first room
                const deskPos = { x: playerStartRoom.x + 1, y: playerStartRoom.y + 1};
                computers.push({ id: 'computer-desk', pos: deskPos, emoji: '🖥️' });
                map[deskPos.y][deskPos.x].walkable = false;

                const elevatorRoom = rooms[rooms.length - 1];
                state.elevator = { id: 'elevator', pos: { x: Math.floor(elevatorRoom.x + elevatorRoom.width / 2), y: Math.floor(elevatorRoom.y + elevatorRoom.height / 2) }, emoji: '🔼' };

                state.map = map;
                state.rooms = rooms; // Store room data for FOV
                state.coworkers = coworkers;
                state.items = items;
                state.computers = computers;
                state.dogs = dogs;
            }

            // --- INITIALIZATION ---
            function init() {
                state = {
                    player: { 
                        id: 'player', 
                        pos: {x:0, y:0}, 
                        emoji: '🧑‍💼', 
                        name: 'You', 
                        productivity: 200, 
                        maxProductivity: 200,
                        happiness: 100, 
                        reputation: 100, 
                        inventory: {},
                        skills: { proficiency: 0, teamwork: 0 }
                    },
                    messages: [],
                    gameOver: false,
                    floor: 1,
                    coworkerTypes: [
                        { name: 'Chatty Charlotte', emoji: '🗣️', effects: { productivity: -15, happiness: 10, reputation: 0 }, behavior: 'chase' },
                        { name: 'The Gossiper', emoji: '🤫', effects: { productivity: -5, happiness: 0, reputation: -15 }, behavior: 'chase' },
                        { name: 'Slacker Sam', emoji: '😴', effects: { productivity: -10, happiness: 5, reputation: -5 }, behavior: 'chase' },
                        { name: 'Productivity Guru', emoji: '🏃', effects: { productivity: 30, happiness: 0, reputation: 0 }, behavior: 'flee' },
                    ],
                    itemTypes: [
                        { name: 'a fresh coffee', emoji: '☕', effects: { productivity: 20, happiness: 0, reputation: 0 } },
                        { name: 'a box of donuts', emoji: '🍩', effects: { productivity: -5, happiness: 20, reputation: 0 } },
                        { name: 'a Synergy Report', emoji: '📝', effects: { productivity: -5, happiness: -5, reputation: -5 } },
                        { name: 'a laptop', emoji: '💻', effects: { productivity: 15, happiness: -5, reputation: 0 } },
                    ]
                };
                
                addMessage("You arrive for another day at the office. Your goal: get that promotion.");
                gameOverOverlay.classList.remove('visible');
                generateLevel();
                calculateFov();
                handleLayout();
            }

            // --- EVENT LISTENERS ---
            window.addEventListener('keydown', (e) => {
                let dx = 0, dy = 0;
                if (e.key === 'ArrowUp') dy = -1;
                else if (e.key === 'ArrowDown') dy = 1;
                else if (e.key === 'ArrowLeft') dx = -1;
                else if (e.key === 'ArrowRight') dx = 1;
                
                if (dx !== 0 || dy !== 0) {
                    e.preventDefault();
                    takePlayerTurn('move', { dx, dy });
                }
            });
            
            inventoryGrid.addEventListener('click', (e) => {
                const slot = e.target.closest('.inventory-slot');
                if (slot) {
                    const itemName = slot.dataset.itemName;
                    takePlayerTurn('use_item', { name: itemName });
                }
            });

            restartButton.addEventListener('click', init);
            
            const debouncedLayoutHandler = debounce(handleLayout, 150);
            window.addEventListener('resize', debouncedLayoutHandler);

            // --- START GAME ---
            init();
        });
    </script>
</body>
</html>


